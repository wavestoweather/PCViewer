#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_NV_shader_subgroup_partitioned : enable

layout(binding = 0) buffer vA{uint aVals[];}; 

layout(binding = 1) buffer vB{uint bVals[];}; 

layout(binding = 2) buffer Lines{
	uint counts[];
};

layout(binding = 3) uniform Infos{
    uint amtOfDataPoints;
    uint aBins, bBins;
    uint padding;
};

layout (local_size_x = 256,local_size_y=1,local_size_z=1) in;

//#define USE_PARTITION
//#define USE_ATOMIC_INC

// as each element of aVals and bVals contain two float16 we have to unpack
void main(){
    if(gl_GlobalInvocationID.x > amtOfDataPoints)
        return;
    float aVal = unpackHalf2x16(aVals[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
    float bVal = unpackHalf2x16(bVals[gl_GlobalInvocationID.x >> 1])[gl_GlobalInvocationID.x & 1];
    uint binA = min(uint(aVal * float(aBins)), aBins - 1);
    uint binB = min(uint(bVal * float(bBins)), bBins - 1);
    //binA = uint(float(gl_GlobalInvocationID.x) / float(amtOfDataPoints) * float(aBins));
    //binB = uint(float(gl_GlobalInvocationID.x * 2) / float(amtOfDataPoints) * float(bBins)) % bBins;
    uint finalBin = binA * bBins + binB;    // linear index

#ifdef USE_PARTITION
    // Find subgroup ( sg ) indices with same pixelID
    uvec4 sg = subgroupPartitionNV(finalBin);
    uint count = subgroupPartitionedAddNV(1, sg);
    uint tId = subgroupPartitionedMinNV(gl_SubgroupInvocationID, sg);
    if(tId == gl_SubgroupInvocationID)
        atomicAdd(counts[finalBin], count);         // incrementing
#endif
#ifdef USE_ATOMIC_INC
    //atomicAdd(counts[finalBin], 1);
    counts[finalBin] += 1;
#else
    // testing if using non atomic count helps the performance
    counts[finalBin] += 1;
#endif
}